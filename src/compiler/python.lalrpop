use std::str::FromStr;
use compiler::ast;


grammar;

pub Program: ast::Program = {
  <s:Statement> => ast::Program { statements: vec![s] },
};

Suite: Vec<ast::Statement> = {
  // Newline Indent <s:Statement+> Dedent => s,
  <s:SimpleStatement> => vec![s],
  Newline <s:Statement> => vec![s],
};

Statement: ast::Statement = {
  SimpleStatement,
  CompoundStatement,
};

SimpleStatement: ast::Statement = {
  <s:SmallStatement> Newline => s,
};

SmallStatement: ast::Statement = {
  <e:Expression> => ast::Statement::Expression { expression: e },
  "break" => ast::Statement::Break,
  "continue" => ast::Statement::Continue,
  "pass" => ast::Statement::Pass,
};

CompoundStatement: ast::Statement = {
  "if" <e:Expression> ":" <s:Suite> => ast::Statement::If { test: e, body: s },
  "while" <e:Expression> ":" <s:Suite> => ast::Statement::While { test: e, body: s },
  "for" <e:Expression> ":" <s:Suite> => ast::Statement::For { test: e },
  "def" <i:Identifier> "(" ")" ":" <s:Suite> => ast::Statement::FunctionDef { name: i, body: s },
};

Expression: ast::Expression = {
  <e:XorExpression> => e,
};

XorExpression: ast::Expression = {
  <e:AndExpression> => e,
};

AndExpression: ast::Expression = {
  <e:ArithmaticExpression> => e,
};

ArithmaticExpression: ast::Expression = {
  <a:ArithmaticExpression> <op:AddOp> <b:Term> => ast::Expression::Binop { a: Box::new(a), op: op, b: Box::new(b) },
  Term,
};

AddOp: ast::Operator = {
  "+" => ast::Operator::Add,
  "-" => ast::Operator::Sub,
};

Term: ast::Expression = {
  <a:Term> <op:MulOp> <b:Factor> => ast::Expression::Binop { a: Box::new(a), op: op, b: Box::new(b) },
  Factor,
};

MulOp: ast::Operator = {
  "*" => ast::Operator::Mult,
  "/" => ast::Operator::Div,
};

Factor: ast::Expression = {
  <e:Power> => e,
};

Power: ast::Expression = {
  <e:Atom>  => e,
};

Atom: ast::Expression = {
  <f:Atom>  "(" <a:FunctionArguments> ")" => ast::Expression::Call { function: Box::new(f), args: a },
  <s:String> => ast::Expression::String { value: s },
  <n:Number> => ast::Expression::Number { value: n },
  <i:Identifier> => ast::Expression::Identifier { name: i },
  "(" <e:Expression> ")" => e,
  "True" => ast::Expression::True,
  "False" => ast::Expression::False,
  "None" => ast::Expression::None,
};

FunctionArguments: Vec<ast::Expression> = {
  <e:Expression> => vec![e],
  <e1:Expression> "," <e2:Expression> => vec![e1, e2],
};

//Comma<T>: Vec<T> = {
//   <v:
//};

Number: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();
String: String = {
  <s:r"'[^']+'"> => String::from(s),
};
Identifier: String = <s:r"[a-z]+"> => String::from(s);
Newline: String = "\n" => String::from(<>);
